<?xml version="1.0" encoding="utf-8"?>
<Demo xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <TargetApplicationTitle>MetaDemo - Microsoft Visual Studio</TargetApplicationTitle>
  <InitialCode />
  <Step Number="1">
    <GhostKeyboardData>[DeleteAll]Brian Friesen

QL.IT.AD.COE.Core.AppCore
C# MVP

brianfriesen@quickenloans.com
@brianfriesen
randomskunk.com</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green128\blue0;\red255\green255\blue255;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Intro\par
-Who I am\par
-What team I'm on\par
-MVP\par
-Contact info\par
}
</Notes>
  </Step>
  <Step Number="2">
    <GhostKeyboardData>[DeleteAll]I'm So Meta, Even This tAlk (ISMETA)
http://xkcd.com/917/</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 I'm So Meta, Even This tAlk (ISMETA)\par
\par
Talk a bit about xkcd. If internet connection is available, go to the link.\par
}
</Notes>
  </Step>
  <Step Number="3">
    <GhostKeyboardData>[DeleteAll]So what is metaprogramming anyway?</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fmodern\fprq1\fcharset0 Consolas;}{\f1\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs24 So what is metaprogramming anyway?\f1\par
}
</Notes>
  </Step>
  <Step Number="4">
    <GhostKeyboardData>[DeleteAll]What is metaprogramming good for?</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 What is metaprogramming good for?\par
\par
TODO: list "when you need to..." examples\par
}
</Notes>
  </Step>
  <Step Number="5">
    <GhostKeyboardData>[DeleteAll]Examples of metaprogramming</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24\par
}
</Notes>
  </Step>
  <Step Number="6">
    <GhostKeyboardData>[DeleteAll]Concerns</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs24 [Pause 5]\par
//\par
// Isn't it dangerous?[Pause 1] Or slow?[Pause 1]\par
// It must be insanely difficult to understand.[Pause 1]\par
}
</Notes>
  </Step>
  <Step Number="7">
    <GhostKeyboardData>[DeleteAll]Scenario - Message Router</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 sScenario\par
\par
Describe the pattern that our system is using.\par
    -ESB\par
    -Messages\par
    -Message Handlers\par
    -Message Router as the "glue" in the system.\par
}
</Notes>
  </Step>
  <Step Number="8">
    <GhostKeyboardData>[DeleteAll]Let's look at some code...</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Ok, so let's start out with our existing implementation.\par
\par
(Execute, then show demo of existing app)\par
\par
Start with Program.cs, show the messages and their handlers. End with MessageRouter.cs.\par
\par
MessageRouter.cs:\par
    -It has the "big switch statement"\par
    -In each case of the switch:\par
        -The message is deserialized into an instance of the "correct" type.\par
        -An instance of a message handler is created for that specific type of message.\par
        -The message is passed to the handler.\par
}
</Notes>
  </Step>
  <Step Number="9">
    <GhostKeyboardData>[DeleteAll][Fast]Advantages of hand-coded MessageRouter[/Fast][Wait][Fast]
  -Easy to understand[/Fast][Wait][Fast]
-Fast[/Fast][Wait][Fast]

[Backspace 1]Disadvantages of hand-coded MessageRouter[/Fast][Wait][Fast]
  -Tedious[/Fast][Wait][Fast]
-New message/handler requires change to MessageRouter[/Fast][Wait][Fast]
-All message/handler types must be known to MessageRouter at compile-time.[/Fast]</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;\red0\green128\blue0;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
\par
                \cf1 switch\cf3  (messageType)\par
                \{\par
                    \cf1 case\cf3  \cf5 "FooMessage"\cf3 :\par
                        \{\par
                            \cf1 var\cf3  message = (\cf4 FooMessage\cf3 )Deserialize(\cf1 typeof\cf3 (\cf4 FooMessage\cf3 ), xmlMessage);\par
                            \cf1 var\cf3  handler = \cf1 new\cf3  \cf4 FooHandler\cf3 ();\par
                            handler.Handle(message);\par
                            \cf1 break\cf3 ;\par
                        \}\par
                    \cf1 case\cf3  \cf5 "BarMessage"\cf3 :\par
                        \{\par
                            \cf1 var\cf3  message = (\cf4 BarMessage\cf3 )Deserialize(\cf1 typeof\cf3 (\cf4 BarMessage\cf3 ), xmlMessage);\par
                            \cf1 var\cf3  handler = \cf1 new\cf3  \cf4 BarHandler\cf3 ();\par
                            handler.Handle(message);\par
                            \cf1 break\cf3 ;\par
                        \}\par
                    \cf1 case\cf3  \cf5 "BazMessage"\cf3 :\par
                        \{\par
                            \cf1 var\cf3  message = (\cf4 BazMessage\cf3 )Deserialize(\cf1 typeof\cf3 (\cf4 BazMessage\cf3 ), xmlMessage);\par
                            \cf1 var\cf3  handler = \cf1 new\cf3  \cf4 BazHandler\cf3 ();\par
                            handler.Handle(message);\par
                            \cf1 break\cf3 ;\par
                        \}\par
                    \cf6 // Imagine dozens or hundreds of messages here.\cf3\par
                    \cf1 default\cf3 :\par
                        LogError(\cf5 "Unknown message type: "\cf3  + messageType);\par
                        \cf1 break\cf3 ;\par
                \}\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf5 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 [Go back to Notes.txt, then execute]\par
\par
Advantages of hand-coded MessageRouter\par
  -Easy to understand[Pause 2]\par
  -Fast[Pause 2]\par
\par
Disadvantages of hand-coded MessageRouter[Pause 5]\par
  -Tedious[Pause 2]\par
  -New message/handler requires change to MessageRouter[Pause 2]\par
  -All message/handler types must be known to MessageRouter at compile-time.\par
}
</Notes>
  </Step>
  <Step Number="10">
    <GhostKeyboardData>[SelectText 42,18 -28,0][Pause 1][DeleteLine][GotoLine 5][GotoLine 12][End][Wait]
// But what do we put here?[Wait][DeleteLine]

[Up][Up][`// For any given message type:
//   1) Deserialize a message object.
//   2) Create a message handler object.
//   3) Pass the message to the message handler's Handle method.`]</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}{\f1\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs24 The body of the Route method contains lots of duplication. For each message type:\par
  1) Deserialize a message object.\par
  2) Create a message handler object.\par
  3) Pass the message object to the message handler's Handle method.\par
\par
So let's get rid of it.\par
\par
But what do we put in its place?\par
\par
Why don't we do what we were doing before, but for arbitrary message types? (resume wait)\par
\par
...and we're going to use reflection to get it done.\par
\par
\par
\f1\par
\par
[Up][Up][End][Down]// But what do we put here?[Wait][DeleteLine]\par
[Up][Fast]// For each[/Fast][Pause 2][Backspace 4][Fast]any given message type:\par
//   1) Deserialize a message object.\par
//   2) Create a message handler object.\par
//   3) Pass the message to the message handler's Handle method.[/Fast]\f0\par
}
</Notes>
  </Step>
  <Step Number="11">
    <GhostKeyboardData>[GotoLine 3][End]
using System.Linq;
using System.Reflection;[Pause 1][GotoLine 20][End]
var message = Deserialize(messageType, xmlMessage);
var handler = CreateMessageHandler(message);
HandleMessage(handler, message);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  message = Deserialize(messageType, xmlMessage);\par
                \cf1 var\cf3  handler = CreateMessageHandler(message);\par
                HandleMessage(handler, message);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Here's some code that would be nice to end up with. So why don't we just go with it and fill it in as we go?\par
}
</Notes>
  </Step>
  <Step Number="12">
    <GhostKeyboardData>[GotoLine 29][End]

private object Deserialize(string messageType, string xmlMessage)
{
[Fast]// This is our first bit of reflection: scanning an assembly for types[/Fast][Pause 1]
var type =
Assembly.GetExecutingAssembly().GetTypes()
    .SingleOrDefault(t =&gt; t.Namespace == "MetaDemo.Messages" &amp;&amp; t.Name == messageType);

return Deserialize(type, xmlMessage);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  message = Deserialize(messageType, xmlMessage);\par
                \cf1 var\cf3  handler = CreateMessageHandler(message);\par
                HandleMessage(handler, message);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf1 string\cf3  messageType, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  type =\par
\f1                 \cf4\f0 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
\f1                     \f0 .Where(t =&gt; t.Namespace == \cf6 "MetaDemo.Messages"\cf3  &amp;&amp; t.Name == messageType);\par
            \cf1 return\cf3  Deserialize(type, xmlMessage);\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Let's start implementing methods, starting with Deserialze.\par
\par
It contains our first bit of reflection - scanning an assembly for types that match a certain criteria.\par
}
</Notes>
  </Step>
  <Step Number="13">
    <GhostKeyboardData>[GotoLine 39][End]

private object CreateMessageHandler(object message)
{
[Fast]// More assembly scanning...[/Fast][Pause 1]
var type = Assembly.GetExecutingAssembly().GetTypes()
.SingleOrDefault(
    t =&gt;
t.Namespace == "MetaDemo.MessageHandlers"
&amp;&amp; !t.IsAbstract
&amp;&amp; t.GetInterfaces().Any(
    i =&gt;
i.IsGenericType
&amp;&amp; i.GetGenericTypeDefinition() == typeof(IMessageHandler&lt;&gt;)
&amp;&amp; i.GetGenericArguments()[0] == message.GetType()));

[Fast]// More reflection: the Activator class.[/Fast]
var handler = Activator.CreateInstance(type);
return handler;</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Moving on to the CreateMessageHandler method.\par
\par
It is going to use reflection twice.\par
}
</Notes>
  </Step>
</Demo>