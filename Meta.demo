<?xml version="1.0" encoding="utf-8"?>
<Demo xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <TargetApplicationTitle>MetaDemo - Microsoft Visual Studio</TargetApplicationTitle>
  <InitialCode />
  <Step Number="1">
    <GhostKeyboardData>[DeleteAll]Brian Friesen

QL.IT.AD.COE.Core.AppCore
C# MVP

brianfriesen@quickenloans.com
@brianfriesen
randomskunk.com</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green128\blue0;\red255\green255\blue255;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Intro\par
-Who I am\par
-What team I'm on\par
-MVP\par
-Contact info\par
}
</Notes>
  </Step>
  <Step Number="2">
    <GhostKeyboardData>[DeleteAll]I'm So Meta, Even This tAlk (ISMETA)
http://xkcd.com/917/</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 I'm So Meta, Even This tAlk (ISMETA)\par
\par
Talk a bit about xkcd. If internet connection is available, go to the link.\par
}
</Notes>
  </Step>
  <Step Number="3">
    <GhostKeyboardData>[DeleteAll]So what is metaprogramming anyway?</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fmodern\fprq1\fcharset0 Consolas;}{\f1\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs24 So what is metaprogramming anyway?\par
\par
When program thinks about the "things" of another program (or itself).\par
\par
reflection\par
code generation\par
t4 templates\par
dynamic\f1\par
}
</Notes>
  </Step>
  <Step Number="4">
    <GhostKeyboardData>[DeleteAll]What is metaprogramming good for?</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 What is metaprogramming good for?\par
\par
When you're implementing...\par
serialization\par
templates\par
mocking\par
dependency injection\par
"convention over configuration"\par
}
</Notes>
  </Step>
  <Step Number="5">
    <GhostKeyboardData>[DeleteAll]Examples of metaprogramming</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 ASP MVC\par
PostSharp\par
Ninject\par
Entity Framework\par
System.Xml.Serialization.XmlSerializer\par
}
</Notes>
  </Step>
  <Step Number="6">
    <GhostKeyboardData>[DeleteAll]Concerns</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs24 [Pause 5]\par
//\par
// Isn't it dangerous?[Pause 1] Or slow?[Pause 1]\par
// It must be insanely difficult to understand.[Pause 1]\par
}
</Notes>
  </Step>
  <Step Number="7">
    <GhostKeyboardData>[DeleteAll]Scenario - Message Router</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Scenario\par
\par
Describe the pattern that our system is using.\par
    -ESB\par
    -Messages\par
    -Message Handlers\par
    -Message Router as the "glue" in the system.\par
}
</Notes>
  </Step>
  <Step Number="8">
    <GhostKeyboardData>[DeleteAll]Let's look at some code...</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Ok, so let's start out with our existing implementation.\par
\par
(Execute, then show demo of existing app)\par
\par
Start with Program.cs, show the messages and their handlers. End with MessageRouter.cs.\par
\par
MessageRouter.cs:\par
    -It has the "big switch statement"\par
    -In each case of the switch:\par
        -The message is deserialized into an instance of the "correct" type.\par
        -An instance of a message handler is created for that specific type of message.\par
        -The message is passed to the handler.\par
}
</Notes>
  </Step>
  <Step Number="9">
    <GhostKeyboardData>[DeleteAll][Fast]Advantages of hand-coded MessageRouter[/Fast][Wait][Fast]
  -Easy to understand[/Fast][Wait][Fast]
-Fast[/Fast][Wait][Fast]

[Backspace 1]Disadvantages of hand-coded MessageRouter[/Fast][Wait][Fast]
  -Tedious[/Fast][Wait][Fast]
-New message/handler requires change to MessageRouter[/Fast][Wait][Fast]
-All message/handler types must be known to MessageRouter at compile-time.[/Fast]</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;\red0\green128\blue0;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
\par
                \cf1 switch\cf3  (messageType)\par
                \{\par
                    \cf1 case\cf3  \cf5 "FooMessage"\cf3 :\par
                        \{\par
                            \cf1 var\cf3  message = (\cf4 FooMessage\cf3 )Deserialize(\cf1 typeof\cf3 (\cf4 FooMessage\cf3 ), xmlMessage);\par
                            \cf1 var\cf3  handler = \cf1 new\cf3  \cf4 FooHandler\cf3 ();\par
                            handler.Handle(message);\par
                            \cf1 break\cf3 ;\par
                        \}\par
                    \cf1 case\cf3  \cf5 "BarMessage"\cf3 :\par
                        \{\par
                            \cf1 var\cf3  message = (\cf4 BarMessage\cf3 )Deserialize(\cf1 typeof\cf3 (\cf4 BarMessage\cf3 ), xmlMessage);\par
                            \cf1 var\cf3  handler = \cf1 new\cf3  \cf4 BarHandler\cf3 ();\par
                            handler.Handle(message);\par
                            \cf1 break\cf3 ;\par
                        \}\par
                    \cf1 case\cf3  \cf5 "BazMessage"\cf3 :\par
                        \{\par
                            \cf1 var\cf3  message = (\cf4 BazMessage\cf3 )Deserialize(\cf1 typeof\cf3 (\cf4 BazMessage\cf3 ), xmlMessage);\par
                            \cf1 var\cf3  handler = \cf1 new\cf3  \cf4 BazHandler\cf3 ();\par
                            handler.Handle(message);\par
                            \cf1 break\cf3 ;\par
                        \}\par
                    \cf6 // Imagine dozens or hundreds of messages here.\cf3\par
                    \cf1 default\cf3 :\par
                        LogError(\cf5 "Unknown message type: "\cf3  + messageType);\par
                        \cf1 break\cf3 ;\par
                \}\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf5 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 [Go back to Notes.txt, then execute]\par
\par
Advantages of hand-coded MessageRouter\par
  -Easy to understand[Pause 2]\par
  -Fast[Pause 2]\par
\par
Disadvantages of hand-coded MessageRouter[Pause 5]\par
  -Tedious[Pause 2]\par
  -New message/handler requires change to MessageRouter[Pause 2]\par
  -All message/handler types must be known to MessageRouter at compile-time.\par
}
</Notes>
  </Step>
  <Step Number="10">
    <GhostKeyboardData>[SelectText 42,18 -28,0][Pause 1][DeleteLine][GotoLine 5][GotoLine 12][End][Wait]
// But what do we put here?[Wait][DeleteLine]

[Up][Up][`// For any given message type:
//   1) Deserialize a message object.
//   2) Create a message handler object.
//   3) Pass the message to the message handler's Handle method.`]</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}{\f1\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs24 The body of the Route method contains lots of duplication. For each message type:\par
  1) Deserialize a message object.\par
  2) Create a message handler object.\par
  3) Pass the message object to the message handler's Handle method.\par
\par
So let's get rid of it.(Execute)\par
\par
But what do we put in its place?\par
\par
Why don't we do what we were doing before, but for arbitrary message types? (resume wait)\par
\par
...and we're going to use reflection to get it done.\par
\par
\par
\f1\par
\par
[Up][Up][End][Down]// But what do we put here?[Wait][DeleteLine]\par
[Up][Fast]// For each[/Fast][Pause 2][Backspace 4][Fast]any given message type:\par
//   1) Deserialize a message object.\par
//   2) Create a message handler object.\par
//   3) Pass the message to the message handler's Handle method.[/Fast]\f0\par
}
</Notes>
  </Step>
  <Step Number="11">
    <GhostKeyboardData>[GotoLine 3][End]
using System.Linq;
using System.Reflection;[Pause 1][GotoLine 20][End]
var message = Deserialize(messageType, xmlMessage);
var handler = CreateMessageHandler(message);
HandleMessage(handler, message);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  message = Deserialize(messageType, xmlMessage);\par
                \cf1 var\cf3  handler = CreateMessageHandler(message);\par
                HandleMessage(handler, message);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Here's some code that would be nice to end up with. So why don't we just go with it and fill it in as we go?\par
}
</Notes>
  </Step>
  <Step Number="12">
    <GhostKeyboardData>[GotoLine 29][End]

private object Deserialize(string messageType, string xmlMessage)
{
[Fast]// This is our first bit of reflection: scanning an assembly for types[/Fast][Pause 1]
var type =
Assembly.GetExecutingAssembly().GetTypes()
    .SingleOrDefault(t =&gt; t.Namespace == "MetaDemo.Messages" &amp;&amp; t.Name == messageType);

return Deserialize(type, xmlMessage);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  message = Deserialize(messageType, xmlMessage);\par
                \cf1 var\cf3  handler = CreateMessageHandler(message);\par
                HandleMessage(handler, message);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf1 string\cf3  messageType, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  type =\par
\f1                 \cf4\f0 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
\f1                     \f0 .Where(t =&gt; t.Namespace == \cf6 "MetaDemo.Messages"\cf3  &amp;&amp; t.Name == messageType);\par
            \cf1 return\cf3  Deserialize(type, xmlMessage);\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Let's start implementing methods, starting with Deserialze.\par
\par
It contains our first bit of reflection - scanning an assembly for types that match a certain criteria.\par
}
</Notes>
  </Step>
  <Step Number="13">
    <GhostKeyboardData>[GotoLine 39][End]

private object CreateMessageHandler(object message)
{
[Fast]// More assembly scanning...[/Fast][Pause 1]
var type = Assembly.GetExecutingAssembly().GetTypes()
.SingleOrDefault(
    t =&gt;
t.Namespace == "MetaDemo.MessageHandlers"
&amp;&amp; !t.IsAbstract
&amp;&amp; t.GetInterfaces().Any(
    i =&gt;
i.IsGenericType
&amp;&amp; i.GetGenericTypeDefinition() == typeof(IMessageHandler&lt;&gt;)
&amp;&amp; i.GetGenericArguments()[0] == message.GetType()));

[Fast]// More reflection: the Activator class.[/Fast]
var handler = Activator.CreateInstance(type);
return handler;</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Moving on to the CreateMessageHandler method.\par
\par
It is going to use reflection twice.\par
}
</Notes>
  </Step>
  <Step Number="14">
    <GhostKeyboardData>[GotoLine 58][End]

private void HandleMessage(object handler, object message)
{
[Fast]// Use reflection to find the correct method to invoke.[/Fast][Pause 1]
var handleMethod =
typeof(IMessageHandler&lt;&gt;).MakeGenericType(message.GetType())
    .GetMethods()
.Single();

[Fast]// Invoke the Handle method using the MethodInfo reflection API...[/Fast][Pause 1]
handleMethod.Invoke(handler, new object[] { message });</GhostKeyboardData>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 And finally, the HandleMessage method.\par
\par
This should complete our reflection-based message router. Let's see if it works...\par
\par
(run application in visual studio)\par
}
</Notes>
  </Step>
  <Step Number="15">
    <GhostKeyboardData>[SelectText 21,17 2,0][Pause 2][CommentLines][Pause 2][SelectText 31,9 39,0][Pause 2][CommentLines]</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
\par
                \cf5 //var message = Deserialize(messageType, xmlMessage);\cf3\par
                \cf5 //var handler = CreateMessageHandler(message);\cf3\par
                \cf5 //HandleMessage(handler, message);\cf3\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf5 //private object Deserialize(string messageType, string xmlMessage)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // This is our first bit of reflection: scanning an assembly for types that match a criteria\cf3\par
        \cf5 //    var type =\cf3\par
        \cf5 //        Assembly.GetExecutingAssembly().GetTypes()\cf3\par
        \cf5 //            .SingleOrDefault(t =&gt; t.Namespace == "MetaDemo.Messages" &amp;&amp; t.Name == messageType);\cf3\par
\par
        \cf5 //    return Deserialize(type, xmlMessage);\cf3\par
        \cf5 //\}\cf3\par
\par
        \cf5 //private object CreateMessageHandler(object message)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // More assembly scanning...\cf3\par
        \cf5 //    var type = Assembly.GetExecutingAssembly().GetTypes()\cf3\par
        \cf5 //        .SingleOrDefault(\cf3\par
        \cf5 //            t =&gt;\cf3\par
        \cf5 //            t.Namespace == "MetaDemo.MessageHandlers"\cf3\par
        \cf5 //            &amp;&amp; !t.IsAbstract\cf3\par
        \cf5 //            &amp;&amp; t.GetInterfaces().Any(\cf3\par
        \cf5 //                i =&gt;\cf3\par
        \cf5 //                i.IsGenericType\cf3\par
        \cf5 //                &amp;&amp; i.GetGenericTypeDefinition() == typeof(IMessageHandler&lt;&gt;)\cf3\par
        \cf5 //                &amp;&amp; i.GetGenericArguments()[0] == message.GetType()));\cf3\par
\par
        \cf5 //    // More reflection: the Activator class.\cf3\par
        \cf5 //    var handler = Activator.CreateInstance(type);\cf3\par
        \cf5 //    return handler;\cf3\par
        \cf5 //\}\cf3\par
\par
        \cf5 //private void HandleMessage(object handler, object message)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // Use reflection to find the correct method to invoke.\cf3\par
        \cf5 //    var handleMethod =\cf3\par
        \cf5 //        typeof(IMessageHandler&lt;&gt;).MakeGenericType(message.GetType())\cf3\par
        \cf5 //            .GetMethods()\cf3\par
        \cf5 //            .Single();\cf3\par
\par
        \cf5 //    // Invoke the Handle method using the MethodInfo reflection API...\cf3\par
        \cf5 //    handleMethod.Invoke(handler, new object[] \{ message \});\cf3\par
        \cf5 //\}\cf3\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 But... this is a very slow implementation.\par
\par
For ever message, we're scanning the assembly each time we receive a message. Twice. And we're searching for the Handle method based on an implementation of IMessageHandler&lt;T&gt;.\par
\par
There is one thing to keep in mind when metaprogramming: caching.\par
\par
Let's comment out our existing implementation... (Execute) ...next step.\par
}
</Notes>
  </Step>
  <Step Number="16">
    <GhostKeyboardData>[GotoLine 3][End][Pause 1]
using System.Collections.Concurrent;[Pause 2][GotoLine 11][End][Pause 1]

[Up]private readonly ConcurrentDictionary&lt;string, Action&lt;string&gt;&gt; _handleFunctions =
new ConcurrentDictionary&lt;string, Action&lt;string&gt;&gt;();[GotoLine 24][End]

[Up][Fast]// Ask our dictionary for the handle function for this message type.
// If none if found, get a handle function from the GetHandleFunction method.[/Fast]
var handle = _handleFunctions.GetOrAdd([Wait]messageType, [Wait]mt =&gt; CreateHandleFunction(mt, xmlMessage));

[Wait][Fast]// Call the function retrieved from the dictionary.[/Fast]
handle(xmlMessage);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt; _handleFunctions =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;();\par
\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
                \par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
\par
                \cf5 // Ask our dictionary for the handle function for this message type.\cf3\par
                \cf5 // If none if found, get a handle function from the GetHandleFunction method.\cf3\par
                \cf1 var\cf3  handle = _handleFunctions.GetOrAdd(messageType, mt =&gt; CreateHandleFunction(mt, xmlMessage));\par
\par
                \cf5 // Call the function retrieved from the dictionary.\cf3\par
                handle(xmlMessage);\par
\par
                \cf5 //var message = Deserialize(messageType, xmlMessage);\cf3\par
                \cf5 //var handler = CreateMessageHandler(message);\cf3\par
                \cf5 //HandleMessage(handler, message);\cf3\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf5 //private object Deserialize(string messageType, string xmlMessage)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // This is our first bit of reflection: scanning an assembly for types that match a criteria\cf3\par
        \cf5 //    var type =\cf3\par
        \cf5 //        Assembly.GetExecutingAssembly().GetTypes()\cf3\par
        \cf5 //            .SingleOrDefault(t =&gt; t.Namespace == "MetaDemo.Messages" &amp;&amp; t.Name == messageType);\cf3\par
\par
        \cf5 //    return Deserialize(type, xmlMessage);\cf3\par
        \cf5 //\}\cf3\par
\par
        \cf5 //private object CreateMessageHandler(object message)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // More assembly scanning...\cf3\par
        \cf5 //    var type = Assembly.GetExecutingAssembly().GetTypes()\cf3\par
        \cf5 //        .SingleOrDefault(\cf3\par
        \cf5 //            t =&gt;\cf3\par
        \cf5 //            t.Namespace == "MetaDemo.MessageHandlers"\cf3\par
        \cf5 //            &amp;&amp; !t.IsAbstract\cf3\par
        \cf5 //            &amp;&amp; t.GetInterfaces().Any(\cf3\par
        \cf5 //                i =&gt;\cf3\par
        \cf5 //                i.IsGenericType\cf3\par
        \cf5 //                &amp;&amp; i.GetGenericTypeDefinition() == typeof(IMessageHandler&lt;&gt;)\cf3\par
        \cf5 //                &amp;&amp; i.GetGenericArguments()[0] == message.GetType()));\cf3\par
\par
        \cf5 //    // More reflection: the Activator class.\cf3\par
        \cf5 //    var handler = Activator.CreateInstance(type);\cf3\par
        \cf5 //    return handler;\cf3\par
        \cf5 //\}\cf3\par
\par
        \cf5 //private void HandleMessage(object handler, object message)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // Use reflection to find the correct method to invoke.\cf3\par
        \cf5 //    var handleMethod =\cf3\par
        \cf5 //        typeof(IMessageHandler&lt;&gt;).MakeGenericType(message.GetType())\cf3\par
        \cf5 //            .GetMethods()\cf3\par
        \cf5 //            .Single();\cf3\par
\par
        \cf5 //    // Invoke the Handle method using the MethodInfo reflection API...\cf3\par
        \cf5 //    handleMethod.Invoke(handler, new object[] \{ message \});\cf3\par
        \cf5 //\}\cf3\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 We're going to be seeing a lot of my good friend, ConcurrentDictionary&lt;,&gt;. We'll use it for caching as much expensive stuff that we can.\par
\par
(Execute) Let's create a field...\par
(Continue, Continue) ...and use ConcurrentDictionary's GetOrAdd method...\par
(Continue) ...pass in our message type as the key to the dictionary...\par
(Continue) ...and method that creates the Action&lt;string&gt; as the value for the message type key.\par
(Continue) What we get back is an Action&lt;string&gt; that we can pass the message xml to.\par
\par
Now we just need to create this CreateHandleFunction method.\par
}
</Notes>
  </Step>
  <Step Number="17">
    <GhostKeyboardData>[GotoLine 40][End][Pause 2]

private Action&lt;string&gt; CreateHandleFunction(string messageTypeName, string xmlMessage)
{[Wait]
[Fast]// Use the same assembly scanning as before to get the message type.[/Fast][Wait]
var messageType =
Assembly.GetExecutingAssembly().GetTypes()
    .SingleOrDefault(t =&gt; t.Namespace == "MetaDemo.Messages" &amp;&amp; t.Name == messageTypeName);

[Wait][Fast]// And use almost the same assembly scanning to get the message handler type[/Fast][Wait]
var handlerType =
Assembly.GetExecutingAssembly().GetTypes()
    .SingleOrDefault(
    t =&gt;
t.Namespace == "MetaDemo.MessageHandlers"
&amp;&amp; !t.IsAbstract
&amp;&amp; t.GetInterfaces().Any(
    i =&gt;
i.IsGenericType
&amp;&amp; i.GetGenericTypeDefinition() == typeof(IMessageHandler&lt;&gt;)
&amp;&amp; i.GetGenericArguments()[0] == messageType));

[Wait][Fast]// And  find the handle method in almost the same way.[/Fast][Wait]
var handleMethod =
typeof(IMessageHandler&lt;&gt;).MakeGenericType(messageType)
    .GetMethods()
.Single();

[Wait][Fast]// This is all we can cache. Let's make a function![/Fast][Wait]
return
xml =&gt;
{
var message = Deserialize(messageType, xmlMessage);
var handler = Activator.CreateInstance(handlerType);
handleMethod.Invoke(handler, new object[] { message });[Down];</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  MetaDemo.Messages;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt; _handleFunctions =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;();\par
\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf5 // For any given message type:\cf3\par
                \cf5 //   1) Deserialize a message object.\cf3\par
                \cf5 //   2) Create a message handler object.\cf3\par
                \cf5 //   3) Pass the message to the message handler's Handle method.\cf3\par
\par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
\par
                \cf5 // Ask our dictionary for the handle function for this message type.\cf3\par
                \cf5 // If none if found, get a handle function from the GetHandleFunction method.\cf3\par
                \cf1 var\cf3  handle = _handleFunctions.GetOrAdd(messageType, mt =&gt; CreateHandleFunction(mt, xmlMessage));\par
\par
                \cf5 // Call the function retrieved from the dictionary.\cf3\par
                handle(xmlMessage);\par
\par
                \cf5 //var message = Deserialize(messageType, xmlMessage);\cf3\par
                \cf5 //var handler = CreateMessageHandler(message);\cf3\par
                \cf5 //HandleMessage(handler, message);\cf3\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt; CreateHandleFunction(\cf1 string\cf3  messageTypeName, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf5 // Use the same assembly scanning as before to get the message type.\cf3\par
            \cf1 var\cf3  messageType =\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(t =&gt; t.Namespace == \cf6 "MetaDemo.Messages"\cf3  &amp;&amp; t.Name == messageTypeName);\par
\par
            \cf5 // And use almost the same assembly scanning to get the message handler type\cf3\par
            \cf1 var\cf3  handlerType =\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(\par
                        t =&gt;\par
                        t.Namespace == \cf6 "MetaDemo.MessageHandlers"\cf3\par
                        &amp;&amp; !t.IsAbstract\par
                        &amp;&amp; t.GetInterfaces().Any(\par
                            i =&gt;\par
                            i.IsGenericType\par
                            &amp;&amp; i.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;)\par
                            &amp;&amp; i.GetGenericArguments()[0] == messageType));\par
\par
            \cf5 // And  find the handle method in almost the same way.\cf3\par
            \cf1 var\cf3  handleMethod =\par
                \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;).MakeGenericType(messageType)\par
                    .GetMethods()\par
                    .Single();\par
\par
            \cf5 // This is all we can cache. Let's make a function!\cf3\par
            \cf1 return\cf3\par
                xml =&gt;\par
                    \{\par
                        \cf1 var\cf3  message = Deserialize(messageType);\par
                        \cf1 var\cf3  handler = \cf4 Activator\cf3 .CreateInstance(handlerType);\par
                        handler.Invoke(handler, \cf1 new\cf3  \cf1 object\cf3 [] \{ message \});\par
                    \}\par
        \}\par
\par
        \cf5 //private object Deserialize(string messageType, string xmlMessage)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // This is our first bit of reflection: scanning an assembly for types that match a criteria\cf3\par
        \cf5 //    var type =\cf3\par
        \cf5 //        Assembly.GetExecutingAssembly().GetTypes()\cf3\par
        \cf5 //            .SingleOrDefault(t =&gt; t.Namespace == "MetaDemo.Messages" &amp;&amp; t.Name == messageType);\cf3\par
\par
        \cf5 //    return Deserialize(type, xmlMessage);\cf3\par
        \cf5 //\}\cf3\par
\par
        \cf5 //private object CreateMessageHandler(object message)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // More assembly scanning...\cf3\par
        \cf5 //    var type = Assembly.GetExecutingAssembly().GetTypes()\cf3\par
        \cf5 //        .SingleOrDefault(\cf3\par
        \cf5 //            t =&gt;\cf3\par
        \cf5 //            t.Namespace == "MetaDemo.MessageHandlers"\cf3\par
        \cf5 //            &amp;&amp; !t.IsAbstract\cf3\par
        \cf5 //            &amp;&amp; t.GetInterfaces().Any(\cf3\par
        \cf5 //                i =&gt;\cf3\par
        \cf5 //                i.IsGenericType\cf3\par
        \cf5 //                &amp;&amp; i.GetGenericTypeDefinition() == typeof(IMessageHandler&lt;&gt;)\cf3\par
        \cf5 //                &amp;&amp; i.GetGenericArguments()[0] == message.GetType()));\cf3\par
\par
        \cf5 //    // More reflection: the Activator class.\cf3\par
        \cf5 //    var handler = Activator.CreateInstance(type);\cf3\par
        \cf5 //    return handler;\cf3\par
        \cf5 //\}\cf3\par
\par
        \cf5 //private void HandleMessage(object handler, object message)\cf3\par
        \cf5 //\{\cf3\par
        \cf5 //    // Use reflection to find the correct method to invoke.\cf3\par
        \cf5 //    var handleMethod =\cf3\par
        \cf5 //        typeof(IMessageHandler&lt;&gt;).MakeGenericType(message.GetType())\cf3\par
        \cf5 //            .GetMethods()\cf3\par
        \cf5 //            .Single();\cf3\par
\par
        \cf5 //    // Invoke the Handle method using the MethodInfo reflection API...\cf3\par
        \cf5 //    handleMethod.Invoke(handler, new object[] \{ message \});\cf3\par
        \cf5 //\}\cf3\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 (Play)We're going to cache as much as we can into the function that we return through closures.\par
(Continue) The first of those is the Type of the message object. [continue immediately]\par
(Continue) We'll scan as before, and store it in a local variable.\par
(Continue) The second to cache is the Type of the message handler object. We'll scan like before... [continue immediately]\par
(Continue) ...the only difference is that we're using messageType instead of calling message.GetType().\par
(Continue) Last is the MethodInfo for the Handle method.\par
(Continue) (same difference: messageType vs message.GetType())\par
(Continue) That's it. Time to make a function! [continue immediately]\par
(Continue) Looks pretty familiar, huh?\par
}
</Notes>
  </Step>
  <Step Number="18">
    <GhostKeyboardData>[SelectText 36,21 1,41][Wait][Up 2][Left 6][SelectTextFromHere 4,60][Wait][CommentLines][Up]

[Up]</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt; _handleFunctions =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;();\par
\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  handle = _handleFunctions.GetOrAdd(messageType, mt =&gt; CreateHandleFunction(mt, xmlMessage));\par
                handle(xmlMessage);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt; CreateHandleFunction(\cf1 string\cf3  messageTypeName, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  messageType = GetTypeOfMessage(messageTypeName);\par
            \cf1 var\cf3  handlerType = GetTypeOfMessageHandler(messageType);\par
            \cf1 var\cf3  handleMethod = GetHandleMethodInfo(messageType);\par
\par
            \cf1 return\cf3\par
                xml =&gt;\par
                    handleMethod.Invoke(\par
                        \cf4 Activator\cf3 .CreateInstance(handlerType),\par
                        \cf1 new\cf3  \cf1 object\cf3 [] \{ Deserialize(messageType, xml) \});\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessage(\cf1 string\cf3  messageTypeName)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(t =&gt; t.Namespace == \cf5 "MetaDemo.Messages"\cf3  &amp;&amp; t.Name == messageTypeName);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessageHandler(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(\par
                        t =&gt;\par
                        t.Namespace == \cf5 "MetaDemo.MessageHandlers"\cf3\par
                        &amp;&amp; !t.IsAbstract\par
                        &amp;&amp; t.GetInterfaces().Any(\par
                            i =&gt;\par
                            i.IsGenericType\par
                            &amp;&amp; i.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;)\par
                            &amp;&amp; i.GetGenericArguments()[0] == messageType));\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 MethodInfo\cf3  GetHandleMethodInfo(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;).MakeGenericType(messageType)\par
                    .GetMethods()\par
                    .Single();\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf5 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Let's clean up a bit...\par
\par
(push finished code to application)\par
\par
Take a look at what we have. About 70 lines of code. Nothing too complex. And we've optimized a bit.\par
\par
(Execute) There's still some performance impact from the reflection that occurs each message (Right here - MethodInfo.Invoke, Activator.CreateInstance). If only there was a way to do that...\par
\par
Well, it turns out there is. So let's get rid of this and speed things up even more. (Continue)\par
}
</Notes>
  </Step>
  <Step Number="19">
    <GhostKeyboardData>[GotoLine 34][End][Fast]// We're creating an expression tree, then we'll compile it and returning the resulting Action&lt;string&gt;.
            
// Our expression tree will consist of three main components:
//   1) A call to the Deserialize method
//        Parameters: messageType as constant (found above); xmlMessage as parameter to the lambda expression.
//   2) A call to the constructor of handlerType
//   3) A call to the Handle method
//        Instance: the result of the call to the constructor of handlerType
//        Parameters: the result of the call to the Deserialize method

[/Fast]</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt; _handleFunctions =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;();\par
\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  handle = _handleFunctions.GetOrAdd(messageType, mt =&gt; CreateHandleFunction(mt, xmlMessage));\par
                handle(xmlMessage);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt; CreateHandleFunction(\cf1 string\cf3  messageTypeName, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  messageType = GetTypeOfMessage(messageTypeName);\par
            \cf1 var\cf3  handlerType = GetTypeOfMessageHandler(messageType);\par
            \cf1 var\cf3  handleMethod = GetHandleMethodInfo(messageType);\par
\par
            \cf5 // We're creating an expression tree, then we'll compile it and returning the resulting Action&lt;string&gt;.\cf3\par
                        \par
            \cf5 // Our expression tree will consist of three main components:\cf3\par
            \cf5 //   1) A call to the Deserialize method\cf3\par
            \cf5 //        Parameters: messageType as constant (found above); xmlMessage as parameter to the lambda expression.\cf3\par
            \cf5 //   2) A call to the constructor of handlerType\cf3\par
            \cf5 //   3) A call to the Handle method\cf3\par
            \cf5 //        Instance: the result of the call to the constructor of handlerType\cf3\par
            \cf5 //        Parameters: the result of the call to the Deserialize method\cf3\par
\par
\par
\par
            \cf5 //return\cf3\par
            \cf5 //    xml =&gt;\cf3\par
            \cf5 //        handleMethod.Invoke(\cf3\par
            \cf5 //            Activator.CreateInstance(handlerType),\cf3\par
            \cf5 //            new object[] \{ Deserialize(messageType, xml) \});\cf3\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessage(\cf1 string\cf3  messageTypeName)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(t =&gt; t.Namespace == \cf6 "MetaDemo.Messages"\cf3  &amp;&amp; t.Name == messageTypeName);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessageHandler(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(\par
                        t =&gt;\par
                        t.Namespace == \cf6 "MetaDemo.MessageHandlers"\cf3\par
                        &amp;&amp; !t.IsAbstract\par
                        &amp;&amp; t.GetInterfaces().Any(\par
                            i =&gt;\par
                            i.IsGenericType\par
                            &amp;&amp; i.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;)\par
                            &amp;&amp; i.GetGenericArguments()[0] == messageType));\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 MethodInfo\cf3  GetHandleMethodInfo(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;).MakeGenericType(messageType)\par
                    .GetMethods()\par
                    .Single();\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 We need a plan of attack. (trust me, it gets easier the more times you've done it)\par
}
</Notes>
  </Step>
  <Step Number="20">
    <GhostKeyboardData>[GotoLine 4][End]
using System.Linq.Expressions;[Pause 1][GotoLine 45][End][Pause 1][Fast]// First we need to define the parameter for the expression.[/Fast]
var xmlMessageParameter = Expression.Parameter(typeof(string), "xmlMessage");[Wait]

[Fast]// Create the call to the Deserialize method.
// First, we need to get a MethodInfo for the Deserialize method[/Fast]
var deserializeMethod = this.GetType().GetMethod("Deserialize", BindingFlags.NonPublic | BindingFlags.Instance);
var callDeserialize =
Expression.Call(
    Expression.Constant(this),[Fast] // The instance that the Deserialize method is attached to, as a closure in the expression[/Fast]
deserializeMethod,
Expression.Constant(messageType),[Fast] // arg 1: another closure - messageType[/Fast]
xmlMessageParameter);[Fast] // arg 2: the parameter to the lambda expression, xmlMessage[/Fast][Wait]

[Fast]// The constructor for the handler type is easy.[/Fast]
var handlerTypeConstructor = Expression.New(handlerType);[Wait]

[Fast]// The call to the Handle method...[/Fast]
var callHandle =
Expression.Call(
    handlerTypeConstructor,[Fast] // The instance that the Handle method is attached to, the result of the handler type constructor call.[/Fast]
handleMethod,[Fast] // The method to call, as discovered at the beginning of this method.[/Fast]
Expression.Convert(callDeserialize, messageType));[Fast] // arg 1: The message object, resulting from a call to Deserialize method, converted to messageType.[/Fast][Wait]

[Fast]// Wrap it all up. The callHandle expression is our body and
// we've already used the parameter expression once already.[/Fast]
var lambda = Expression.Lambda&lt;Action&lt;string&gt;&gt;(callHandle, xmlMessageParameter);
return lambda.Compile();</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Linq.Expressions;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt; _handleFunctions =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;();\par
\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  handle = _handleFunctions.GetOrAdd(messageType, mt =&gt; CreateHandleFunction(mt, xmlMessage));\par
                handle(xmlMessage);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt; CreateHandleFunction(\cf1 string\cf3  messageTypeName, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  messageType = GetTypeOfMessage(messageTypeName);\par
            \cf1 var\cf3  handlerType = GetTypeOfMessageHandler(messageType);\par
            \cf1 var\cf3  handleMethod = GetHandleMethodInfo(messageType);\par
\par
            \cf5 // We're creating an expression tree, then we'll compile it and returning the resulting Action&lt;string&gt;.\cf3\par
                        \par
            \cf5 // Our expression tree will consist of three main components:\cf3\par
            \cf5 //   1) A call to the Deserialize method\cf3\par
            \cf5 //        Parameters: messageType as constant (found above); xmlMessage as parameter to the lambda expression.\cf3\par
            \cf5 //   2) A call to the constructor of handlerType\cf3\par
            \cf5 //   3) A call to the Handle method\cf3\par
            \cf5 //        Instance: the result of the call to the constructor of handlerType\cf3\par
            \cf5 //        Parameters: the result of the call to the Deserialize method\cf3\par
\par
            \cf5 // First we need to define the parameter for the expression.\cf3\par
            \cf1 var\cf3  xmlMessageParameter = \cf4 Expression\cf3 .Parameter(\cf1 typeof\cf3 (\cf1 string\cf3 ), \cf6 "xmlMessage"\cf3 );\par
\par
            \cf5 // Create the call to the Deserialize method.\cf3\par
            \cf5 // First, we need to get a MethodInfo for the Deserialize method\cf3\par
            \cf1 var\cf3  deserializeMethod = \cf1 this\cf3 .GetType().GetMethod(\cf6 "Deserialize"\cf3 , \cf4 BindingFlags\cf3 .NonPublic | \cf4 BindingFlags\cf3 .Instance);\par
            \cf1 var\cf3  callDeserialize =\par
                \cf4 Expression\cf3 .Call(\par
                    \cf4 Expression\cf3 .Constant(\cf1 this\cf3 ), \cf5 // The instance that the Deserialize method is attached to, as a closure in the expression\cf3\par
                    deserializeMethod,\par
                    \cf4 Expression\cf3 .Constant(messageType), \cf5 // arg 1: another closure - messageType\cf3\par
                    xmlMessageParameter); \cf5 // arg 2: the parameter to the lambda expression, xmlMessage\cf3\par
\par
            \cf5 // The constructor for the handler type is easy.\cf3\par
            \cf1 var\cf3  handlerTypeConstructor = \cf4 Expression\cf3 .New(handlerType);\par
\par
            \cf5 // The call to the Handle method...\cf3\par
            \cf1 var\cf3  callHandle =\par
                \cf4 Expression\cf3 .Call(\par
                    handlerTypeConstructor, \cf5 // The instance that the Handle method is attached to, the result of the handler type constructor call.\cf3\par
                    handleMethod, \cf5 // The method to call, as discovered at the beginning of this method.\cf3\par
                    \cf4 Expression\cf3 .Convert(callDeserialize, messageType)); \cf5 // arg 1: The message object, resulting from a call to Deserialize method, converted to messageType.\cf3\par
\par
            \cf5 // Wrap it all up. The callHandle expression is our body and\cf3\par
            \cf5 // we've already used the parameter expression once already.\cf3\par
            \cf1 var\cf3  lambda = \cf4 Expression\cf3 .Lambda&lt;\cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;(callHandle, xmlMessageParameter);\par
            \cf1 return\cf3  lambda.Compile();\par
\par
            \cf5 //return\cf3\par
            \cf5 //    xml =&gt;\cf3\par
            \cf5 //        handleMethod.Invoke(\cf3\par
            \cf5 //            Activator.CreateInstance(handlerType),\cf3\par
            \cf5 //            new object[] \{ Deserialize(messageType, xml) \});\cf3\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessage(\cf1 string\cf3  messageTypeName)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(t =&gt; t.Namespace == \cf6 "MetaDemo.Messages"\cf3  &amp;&amp; t.Name == messageTypeName);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessageHandler(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(\par
                        t =&gt;\par
                        t.Namespace == \cf6 "MetaDemo.MessageHandlers"\cf3\par
                        &amp;&amp; !t.IsAbstract\par
                        &amp;&amp; t.GetInterfaces().Any(\par
                            i =&gt;\par
                            i.IsGenericType\par
                            &amp;&amp; i.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;)\par
                            &amp;&amp; i.GetGenericArguments()[0] == messageType));\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 MethodInfo\cf3  GetHandleMethodInfo(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;).MakeGenericType(messageType)\par
                    .GetMethods()\par
                    .Single();\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf6 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 TODO: Notes on the little steps in this slide (there are many!)\par
}
</Notes>
  </Step>
  <Step Number="21">
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  MetaDemo.MessageHandlers;\par
\cf1 using\cf3  System;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Linq.Expressions;\par
\cf1 using\cf3  System.Reflection;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 class\cf3  \cf4 MessageRouter\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 MethodInfo\cf3  _deserializeMethod =\par
            \cf1 typeof\cf3 (\cf4 MessageRouter\cf3 ).GetMethod(\cf5 "Deserialize"\cf3 , \cf4 BindingFlags\cf3 .NonPublic | \cf4 BindingFlags\cf3 .Instance);\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt; _handleFunctions =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf1 string\cf3 , \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;();\par
\par
        \cf1 public\cf3  \cf1 void\cf3  Route(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 try\cf3\par
            \{\par
                \cf1 var\cf3  messageType = GetMessageType(xmlMessage);\par
                \cf1 var\cf3  handle = _handleFunctions.GetOrAdd(messageType, mt =&gt; CreateHandleFunction(mt, xmlMessage));\par
                handle(xmlMessage);\par
            \}\par
            \cf1 catch\cf3  (\cf4 Exception\cf3  ex)\par
            \{\par
                LogError(ex.Message);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Action\cf3 &lt;\cf1 string\cf3 &gt; CreateHandleFunction(\cf1 string\cf3  messageTypeName, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  messageType = GetTypeOfMessage(messageTypeName);\par
            \cf1 var\cf3  handlerType = GetTypeOfMessageHandler(messageType);\par
            \cf1 var\cf3  handleMethod = GetHandleMethodInfo(messageType);\par
\par
            \cf1 var\cf3  xmlMessageParameter = \cf4 Expression\cf3 .Parameter(\cf1 typeof\cf3 (\cf1 string\cf3 ), \cf5 "xmlMessage"\cf3 );\par
\par
            \cf1 var\cf3  callDeserialize =\par
                \cf4 Expression\cf3 .Call(\par
                    \cf4 Expression\cf3 .Constant(\cf1 this\cf3 ),\par
                    _deserializeMethod,\par
                    \cf4 Expression\cf3 .Constant(messageType),\par
                    xmlMessageParameter);\par
\par
            \cf1 var\cf3  newMessageHandler = \cf4 Expression\cf3 .New(handlerType);\par
\par
            \cf1 var\cf3  callHandle =\par
                \cf4 Expression\cf3 .Call(\par
                    newMessageHandler,\par
                    handleMethod,\par
                    \cf4 Expression\cf3 .Convert(callDeserialize, messageType));\par
\par
            \cf1 var\cf3  lambda = \cf4 Expression\cf3 .Lambda&lt;\cf4 Action\cf3 &lt;\cf1 string\cf3 &gt;&gt;(callHandle, xmlMessageParameter);\par
            \cf1 return\cf3  lambda.Compile();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessage(\cf1 string\cf3  messageTypeName)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(t =&gt; t.Namespace == \cf5 "MetaDemo.Messages"\cf3  &amp;&amp; t.Name == messageTypeName);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 Type\cf3  GetTypeOfMessageHandler(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf4 Assembly\cf3 .GetExecutingAssembly().GetTypes()\par
                    .SingleOrDefault(\par
                        t =&gt;\par
                        t.Namespace == \cf5 "MetaDemo.MessageHandlers"\cf3\par
                        &amp;&amp; !t.IsAbstract\par
                        &amp;&amp; t.GetInterfaces().Any(\par
                            i =&gt;\par
                            i.IsGenericType\par
                            &amp;&amp; i.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;)\par
                            &amp;&amp; i.GetGenericArguments()[0] == messageType));\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 MethodInfo\cf3  GetHandleMethodInfo(\cf4 Type\cf3  messageType)\par
        \{\par
            \cf1 return\cf3\par
                \cf1 typeof\cf3 (\cf4 IMessageHandler\cf3 &lt;&gt;).MakeGenericType(messageType)\par
                    .GetMethods()\par
                    .Single();\par
        \}\par
\par
\cf1         #region\cf3  Plumbing (i.e. not relevant to the talk)\par
\par
        \cf1 private\cf3  \cf1 string\cf3  GetMessageType(\cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  doc = System.Xml.Linq.\cf4 XDocument\cf3 .Parse(xmlMessage);\par
            \cf1 return\cf3  doc.Root.Name.LocalName;\par
        \}\par
\par
        \cf1 private\cf3  \cf1 object\cf3  Deserialize(\cf4 Type\cf3  type, \cf1 string\cf3  xmlMessage)\par
        \{\par
            \cf1 var\cf3  serializer = \cf1 new\cf3  System.Xml.Serialization.\cf4 XmlSerializer\cf3 (type);\par
            \cf1 using\cf3  (\cf1 var\cf3  reader = \cf1 new\cf3  System.IO.\cf4 StringReader\cf3 (xmlMessage))\par
            \{\par
                \cf1 return\cf3  serializer.Deserialize(reader);\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 void\cf3  LogError(\cf1 string\cf3  message)\par
        \{\par
            \cf4 Console\cf3 .WriteLine(\cf5 "ERROR: "\cf3  + message);\par
        \}\par
\par
\cf1         #endregion\cf3\par
    \}\par
\}\par
\cf1\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Let's do a little bit of clean up and see what we have. (push finished code to application)\par
\par
Not bad huh?\par
\par
Any questions?\par
}
</Notes>
  </Step>
  <Step Number="22">
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3\par
    \{\par
    \}\par
\}\par
\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Next up... DeepEqualityComparer\par
\par
1) Set the DeepEqualityComparer project as the startup project.\par
2) Review existing code in Program.cs.\par
3) Show the nasty Equals method.\par
}
</Notes>
  </Step>
  <Step Number="23">
    <GhostKeyboardData>[SelectText 73,10 42,0][Delete 1][Up 2][Right 16][Wait]DeepEqualityComparer.Instance.</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Consolas;}}
\viewkind4\uc1\pard\f0\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 That Equals method is pretty nasty. And it only covers the Foo class!\par
\par
Let's get rid of it.\par
(Continue) And in its place, let's make a call to a singleton instance of IEqualityComparer.\par
...which doesn't really exist...yet.\par
}
</Notes>
  </Step>
  <Step Number="24">
    <GhostKeyboardData>[DeleteAll]using System;
using System.Collections;

namespace MetaDemo
{
public sealed class DeepEqualityComparer : IEqualityComparer
{
private static readonly DeepEqualityComparer _instance = new DeepEqualityComparer();

private DeepEqualityComparer()
{
[DeleteLine][End]

public static IEqualityComparer Instance
{
get {return _instance;[End][Down 1]

public bool Equals(object lhs, object rhs)
{
throw new NotImplementedException();[Down 1]

public int GetHashCode(object obj)
{
throw new NotImplementedException();</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Collections;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 **Move to DeepEqualityComparer.cs before executing**\par
\par
So we already said we were going to use a singleton instance, so let's implement the singleton pattern.\par
And we'll implement IEqualityComparer while we're at it...\par
}
</Notes>
  </Step>
  <Step Number="25">
    <GhostKeyboardData>[GotoLine 2][End]
using System.Collections.Generic;[Pause 1][GotoLine 18][End]

private static IEqualityComparer&lt;T&gt; GetGenericInstance&lt;T&gt;()
{
return GenericDeepEqualityComparer&lt;T&gt;.Instance;[Wait][GotoLine 33][End]

private sealed class GenericDeepEqualityComparer&lt;T&gt; : IEqualityComparer&lt;T&gt;
{
private static readonly GenericDeepEqualityComparer&lt;T&gt; _instance = new GenericDeepEqualityComparer&lt;T&gt;();

private GenericDeepEqualityComparer()
{
[DeleteLine][End]

public static IEqualityComparer&lt;T&gt; Instance
{
get {return _instance;[End][Down 1]

public bool Equals(T lhs, T rhs)
{
return DeepEqualityComparer.Instance.Equals(lhs, rhs);[End][Down 1]

public int GetHashCode(T obj)
{
return DeepEqualityComparer.Instance.GetHashCode(obj);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 (Execute - it takes a while)\par
Let's give ourselves the ability to easily retrive a generic IEqualityComparer&lt;&gt;. The generic implementation\par
won't add any functionality - it'll just call the singleton's methods.\par
}
</Notes>
  </Step>
  <Step Number="26">
    <GhostKeyboardData>[SelectText 27,13 0,36][Pause 1][Delete 1][Wait]if (lhs == null &amp;&amp; rhs == null)
{
return true;[Wait][Down]

if (lhs == null
|| rhs == null
|| lhs.GetType() != rhs.GetType())
{
return false;
</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
\par
            \}\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Our plumbing is all finished. Time to implement the two interface methods. Let's start with Equals.\par
\par
(Continue) Let's start out by taking care of null. If both values are null, we're equal.\par
(Continue) Then, if either is true (because at this point, they're not both true), we're not equal. Or if the types don't match, we're not equal.\par
}
</Notes>
  </Step>
  <Step Number="27">
    <GhostKeyboardData>[GotoLine 37][End]

var type = lhs.GetType();

if (IsPrimitivish(type))
{
return lhs.Equals(rhs);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Now let's grab the objects' type and see if it is primitive-like. If it is, just return the result of the object's Equals method.\par
}
</Notes>
  </Step>
  <Step Number="28">
    <GhostKeyboardData>[GotoLine 1][End]
using System.Linq;[Pause 1][GotoLine 45][End]

if (typeof(IEnumerable).IsAssignableFrom(type))
{
var lhsList = ((IEnumerable)lhs).Cast&lt;object&gt;().ToList();
var rhsList = ((IEnumerable)rhs).Cast&lt;object&gt;().ToList();

if (lhsList.Count != rhsList.Count)
{
return false;[Down 1]

return 
lhsList
    .Zip(rhsList, (l, r) =&gt; this.Equals(l, r))
.All(x =&gt; x);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 var\cf3  lhsList = ((\cf4 IEnumerable\cf3 )lhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
                \cf1 var\cf3  rhsList = ((\cf4 IEnumerable\cf3 )rhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
\par
                \cf1 if\cf3  (lhsList.Count != rhsList.Count)\par
                \{\par
                    \cf1 return\cf3  \cf1 false\cf3 ;\par
                \}\par
\par
                \cf1 return\cf3\par
                    lhsList\par
                        .Zip(rhsList, (l, r) =&gt; \cf1 this\cf3 .Equals(l, r))\par
                        .All(x =&gt; x);\par
            \}\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 [Execute immediately] Now we need to take care of lists of things. This should be good enough.\par
}
</Notes>
  </Step>
  <Step Number="29">
    <GhostKeyboardData>[GotoLine 61][End][Pause 1]

return
GetPropertyAccessors(type)
    .All(getPropertyValue =&gt; this.Equals(getPropertyValue(lhs), getPropertyValue(rhs)));</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 var\cf3  lhsList = ((\cf4 IEnumerable\cf3 )lhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
                \cf1 var\cf3  rhsList = ((\cf4 IEnumerable\cf3 )rhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
\par
                \cf1 if\cf3  (lhsList.Count != rhsList.Count)\par
                \{\par
                    \cf1 return\cf3  \cf1 false\cf3 ;\par
                \}\par
\par
                \cf1 return\cf3\par
                    lhsList\par
                        .Zip(rhsList, (l, r) =&gt; \cf1 this\cf3 .Equals(l, r))\par
                        .All(x =&gt; x);\par
            \}\par
\par
            \cf1 return\cf3\par
                GetPropertyAccessors(type)\par
                    .All(getPropertyValue =&gt; \cf1 this\cf3 .Equals(getPropertyValue(lhs), getPropertyValue(rhs)));\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 And finally, take care of the properties of each object.\par
}
</Notes>
  </Step>
  <Step Number="30">
    <GhostKeyboardData>[GotoLine 10][End]

private readonly Type[] _primitivishTypes =
{
typeof(string),
typeof(decimal),
typeof(DateTime),
typeof(Guid)[Down];[Wait][GotoLine 79][End]

private bool IsPrimitivish(Type type)
{
return IsNonNullablePrimitivish(type) || IsNullablePrimitivish(type);[End][Down]

private bool IsNonNullablePrimitivish(Type type)
{
return type.IsPrimitive || _primitivishTypes.Contains(type);[End][Down]

private bool IsNullablePrimitivish(Type type)
{
return
type.IsGenericType
&amp;&amp; type.GetGenericTypeDefinition() == typeof(Nullable&lt;&gt;)
&amp;&amp; IsNonNullablePrimitivish(type.GetGenericArguments()[0]);</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 Type\cf3 [] _primitivishTypes =\par
        \{\par
            \cf1 typeof\cf3 (\cf1 string\cf3 ),\par
            \cf1 typeof\cf3 (\cf1 decimal\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 DateTime\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 Guid\cf3 )\par
        \};\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 var\cf3  lhsList = ((\cf4 IEnumerable\cf3 )lhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
                \cf1 var\cf3  rhsList = ((\cf4 IEnumerable\cf3 )rhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
\par
                \cf1 if\cf3  (lhsList.Count != rhsList.Count)\par
                \{\par
                    \cf1 return\cf3  \cf1 false\cf3 ;\par
                \}\par
\par
                \cf1 return\cf3\par
                    lhsList\par
                        .Zip(rhsList, (l, r) =&gt; \cf1 this\cf3 .Equals(l, r))\par
                        .All(x =&gt; x);\par
            \}\par
\par
            \cf1 return\cf3\par
                GetPropertyAccessors(type)\par
                    .All(getPropertyValue =&gt; \cf1 this\cf3 .Equals(getPropertyValue(lhs), getPropertyValue(rhs)));\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsPrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  IsNonNullablePrimitivish(type) || IsNullablePrimitivish(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNonNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  type.IsPrimitive || _primitivishTypes.Contains(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                type.IsGenericType\par
                &amp;&amp; type.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 Nullable\cf3 &lt;&gt;)\par
                &amp;&amp; IsNonNullablePrimitivish(type.GetGenericArguments()[0]);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Now we need to determine if a type is "primitivish".\par
\par
We'll make a list of all the types that are, for all intents and purposes, primitive.\par
(Continue) Note that we're using a little bit of reflection here.\par
}
</Notes>
  </Step>
  <Step Number="31">
    <GhostKeyboardData>[GotoLine 4][End]
using System.Collections.Concurrent;[Pause 1][GotoLine 19][End][Pause 1]

private readonly ConcurrentDictionary&lt;Type, IEnumerable&lt;Func&lt;object, object&gt;&gt;&gt; _propertyAccessorsMap =
new ConcurrentDictionary&lt;Type, IEnumerable&lt;Func&lt;object, object&gt;&gt;&gt;();[Wait][GotoLine 83][End]

private IEnumerable&lt;Func&lt;object, object&gt;&gt; GetPropertyAccessors(Type type)
{
return
_propertyAccessorsMap.GetOrAdd(
     type,
t =&gt;
(from p in t.GetProperties()
where p.CanRead
let getMethod = p.GetGetMethod()
where getMethod != null &amp;&amp; getMethod.IsPublic
select CreatePropertyAccessor(p)[Right 1].ToList()[Right 1];</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 Type\cf3 [] _primitivishTypes =\par
        \{\par
            \cf1 typeof\cf3 (\cf1 string\cf3 ),\par
            \cf1 typeof\cf3 (\cf1 decimal\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 DateTime\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 Guid\cf3 )\par
        \};\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt; _propertyAccessorsMap =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt;();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 var\cf3  lhsList = ((\cf4 IEnumerable\cf3 )lhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
                \cf1 var\cf3  rhsList = ((\cf4 IEnumerable\cf3 )rhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
\par
                \cf1 if\cf3  (lhsList.Count != rhsList.Count)\par
                \{\par
                    \cf1 return\cf3  \cf1 false\cf3 ;\par
                \}\par
\par
                \cf1 return\cf3\par
                    lhsList\par
                        .Zip(rhsList, (l, r) =&gt; \cf1 this\cf3 .Equals(l, r))\par
                        .All(x =&gt; x);\par
            \}\par
\par
            \cf1 return\cf3\par
                GetPropertyAccessors(type)\par
                    .All(getPropertyValue =&gt; \cf1 this\cf3 .Equals(getPropertyValue(lhs), getPropertyValue(rhs)));\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt; GetPropertyAccessors(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                _propertyAccessorsMap.GetOrAdd(\par
                     type,\par
                     t =&gt;\par
                     (\cf1 from\cf3  p \cf1 in\cf3  t.GetProperties()\par
                      \cf1 where\cf3  p.CanRead\par
                      \cf1 let\cf3  getMethod = p.GetGetMethod()\par
                      \cf1 where\cf3  getMethod != \cf1 null\cf3  &amp;&amp; getMethod.IsPublic\par
                      \cf1 select\cf3  CreatePropertyAccessor(p)).ToList());\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsPrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  IsNonNullablePrimitivish(type) || IsNullablePrimitivish(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNonNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  type.IsPrimitive || _primitivishTypes.Contains(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                type.IsGenericType\par
                &amp;&amp; type.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 Nullable\cf3 &lt;&gt;)\par
                &amp;&amp; IsNonNullablePrimitivish(type.GetGenericArguments()[0]);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\pard\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Now, on to the GetPropertyAccessors method. It needs to return an IEnumerable&lt;Func&lt;object, object&gt;&gt;. This will allow us to easily get the values of all the properties for a class.\par
\par
(Execute) We'll store the IEnumerable&lt;Func&lt;object, object&gt;&gt; in... you guessed it - a ConcurrentDictionary.\par
(Continue) And getting the property accessors should look a little familiar by now.\par
\par
Now we just need to implement the CreatePropertyAccessor method.\par
}
</Notes>
  </Step>
  <Step Number="32">
    <GhostKeyboardData>[GotoLine 5][End]
using System.Reflection;
using System.Linq.Expressions;[Pause 1][GotoLine 98][End][Pause 1]

private Func&lt;object, object&gt; CreatePropertyAccessor(PropertyInfo property)
{
var objParameter = Expression.Parameter(typeof(object), "obj");

Expression getPropertyValueExpression =
Expression.Property(
    Expression.Convert(
    objParameter,
property.DeclaringType),
[Backspace 4]property);

if (property.PropertyType.IsValueType)
{
getPropertyValueExpression = Expression.Convert(getPropertyValueExpression, typeof(object));[End][Down]

var lambda = Expression.Lambda&lt;Func&lt;object, object&gt;&gt;(getPropertyValueExpression, objParameter);
return lambda.Compile();</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Reflection;\par
\cf1 using\cf3  System.Linq.Expressions;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 Type\cf3 [] _primitivishTypes =\par
        \{\par
            \cf1 typeof\cf3 (\cf1 string\cf3 ),\par
            \cf1 typeof\cf3 (\cf1 decimal\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 DateTime\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 Guid\cf3 )\par
        \};\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt; _propertyAccessorsMap =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt;();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 var\cf3  lhsList = ((\cf4 IEnumerable\cf3 )lhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
                \cf1 var\cf3  rhsList = ((\cf4 IEnumerable\cf3 )rhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
\par
                \cf1 if\cf3  (lhsList.Count != rhsList.Count)\par
                \{\par
                    \cf1 return\cf3  \cf1 false\cf3 ;\par
                \}\par
\par
                \cf1 return\cf3\par
                    lhsList\par
                        .Zip(rhsList, (l, r) =&gt; \cf1 this\cf3 .Equals(l, r))\par
                        .All(x =&gt; x);\par
            \}\par
\par
            \cf1 return\cf3\par
                GetPropertyAccessors(type)\par
                    .All(getPropertyValue =&gt; \cf1 this\cf3 .Equals(getPropertyValue(lhs), getPropertyValue(rhs)));\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 throw\cf3  \cf1 new\cf3  \cf4 NotImplementedException\cf3 ();\par
        \}\par
\par
        \cf1 private\cf3  \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt; GetPropertyAccessors(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                _propertyAccessorsMap.GetOrAdd(\par
                     type,\par
                     t =&gt;\par
                     (\cf1 from\cf3  p \cf1 in\cf3  t.GetProperties()\par
                      \cf1 where\cf3  p.CanRead\par
                      \cf1 let\cf3  getMethod = p.GetGetMethod()\par
                      \cf1 where\cf3  getMethod != \cf1 null\cf3  &amp;&amp; getMethod.IsPublic\par
                      \cf1 select\cf3  CreatePropertyAccessor(p)).ToList());\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt; CreatePropertyAccessor(\cf4 PropertyInfo\cf3  property)\par
        \{\par
            \cf1 var\cf3  objParameter = \cf4 Expression\cf3 .Parameter(\cf1 typeof\cf3 (\cf1 object\cf3 ), \cf5 "obj"\cf3 );\par
\par
            \cf4 Expression\cf3  getPropertyValueExpression =\par
                \cf4 Expression\cf3 .Property(\par
                    \cf4 Expression\cf3 .Convert(\par
                        objParameter,\par
                        property.DeclaringType),\par
                    property);\par
\par
            \cf1 if\cf3  (property.PropertyType.IsValueType)\par
            \{\par
                getPropertyValueExpression = \cf4 Expression\cf3 .Convert(getPropertyValueExpression, \cf1 typeof\cf3 (\cf1 object\cf3 ));\par
            \}\par
\par
            \cf1 var\cf3  lambda = \cf4 Expression\cf3 .Lambda&lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;(getPropertyValueExpression, objParameter);\par
            \cf1 return\cf3  lambda.Compile();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsPrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  IsNonNullablePrimitivish(type) || IsNullablePrimitivish(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNonNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  type.IsPrimitive || _primitivishTypes.Contains(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                type.IsGenericType\par
                &amp;&amp; type.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 Nullable\cf3 &lt;&gt;)\par
                &amp;&amp; IsNonNullablePrimitivish(type.GetGenericArguments()[0]);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Finally, to tie it all together.\par
\par
We're creating a expression tree that accesses the value of a property for an object.\par
\par
PHEW! That was a tough! But now we can compare the values of the properties of arbitrary objects. (run the application as proof)\par
}
</Notes>
  </Step>
  <Step Number="33">
    <GhostKeyboardData>[SelectText 84,13 0,36][Pause 1][Delete 1]if (obj == null)
{
return 0;[End][Down]

var type = obj.GetType();

if (IsPrimitivish(type))
{
return obj.GetHashCode();[End][Down]

if (typeof(IEnumerable).IsAssignableFrom(type))
{
return this.GetAggregatedHashCode(type, ((IEnumerable)obj).Cast&lt;object&gt;());[End][Down]

return this.GetAggregatedHashCode(type, GetPropertyAccessors(type).Select(getPropertyValue =&gt; getPropertyValue(obj)));</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Reflection;\par
\cf1 using\cf3  System.Linq.Expressions;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 Type\cf3 [] _primitivishTypes =\par
        \{\par
            \cf1 typeof\cf3 (\cf1 string\cf3 ),\par
            \cf1 typeof\cf3 (\cf1 decimal\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 DateTime\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 Guid\cf3 )\par
        \};\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt; _propertyAccessorsMap =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt;();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 var\cf3  lhsList = ((\cf4 IEnumerable\cf3 )lhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
                \cf1 var\cf3  rhsList = ((\cf4 IEnumerable\cf3 )rhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
\par
                \cf1 if\cf3  (lhsList.Count != rhsList.Count)\par
                \{\par
                    \cf1 return\cf3  \cf1 false\cf3 ;\par
                \}\par
\par
                \cf1 return\cf3\par
                    lhsList\par
                        .Zip(rhsList, (l, r) =&gt; \cf1 this\cf3 .Equals(l, r))\par
                        .All(x =&gt; x);\par
            \}\par
\par
            \cf1 return\cf3\par
                GetPropertyAccessors(type)\par
                    .All(getPropertyValue =&gt; \cf1 this\cf3 .Equals(getPropertyValue(lhs), getPropertyValue(rhs)));\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 if\cf3  (obj == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  0;\par
            \}\par
\par
            \cf1 var\cf3  type = obj.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  \f1 obj\f0 .GetHashCode();\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 return\cf3  \cf1 this\cf3 .GetAggregatedHashCode(type, ((\cf4 IEnumerable\cf3 )obj).Cast&lt;\cf1 object\cf3 &gt;());\par
            \}\par
\par
            \cf1 return\cf3  \cf1 this\cf3 .GetAggregatedHashCode(type, GetPropertyAccessors(type).Select(getPropertyValue =&gt; getPropertyValue(obj)));\par
        \}\par
\par
        \cf1 private\cf3  \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt; GetPropertyAccessors(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                _propertyAccessorsMap.GetOrAdd(\par
                     type,\par
                     t =&gt;\par
                     (\cf1 from\cf3  p \cf1 in\cf3  t.GetProperties()\par
                      \cf1 where\cf3  p.CanRead\par
                      \cf1 let\cf3  getMethod = p.GetGetMethod()\par
                      \cf1 where\cf3  getMethod != \cf1 null\cf3  &amp;&amp; getMethod.IsPublic\par
                      \cf1 select\cf3  CreatePropertyAccessor(p)).ToList());\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt; CreatePropertyAccessor(\cf4 PropertyInfo\cf3  property)\par
        \{\par
            \cf1 var\cf3  objParameter = \cf4 Expression\cf3 .Parameter(\cf1 typeof\cf3 (\cf1 object\cf3 ), \cf5 "obj"\cf3 );\par
\par
            \cf4 Expression\cf3  getPropertyValueExpression =\par
                \cf4 Expression\cf3 .Property(\par
                    \cf4 Expression\cf3 .Convert(\par
                        objParameter,\par
                        property.DeclaringType),\par
                    property);\par
\par
            \cf1 if\cf3  (property.PropertyType.IsValueType)\par
            \{\par
                getPropertyValueExpression = \cf4 Expression\cf3 .Convert(getPropertyValueExpression, \cf1 typeof\cf3 (\cf1 object\cf3 ));\par
            \}\par
\par
            \cf1 var\cf3  lambda = \cf4 Expression\cf3 .Lambda&lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;(getPropertyValueExpression, objParameter);\par
            \cf1 return\cf3  lambda.Compile();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsPrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  IsNonNullablePrimitivish(type) || IsNullablePrimitivish(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNonNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  type.IsPrimitive || _primitivishTypes.Contains(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                type.IsGenericType\par
                &amp;&amp; type.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 Nullable\cf3 &lt;&gt;)\par
                &amp;&amp; IsNonNullablePrimitivish(type.GetGenericArguments()[0]);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 Let's implement GetHashCode - it's really similar to Equals.\par
\par
First do a null check, then a check against primitives. Then an enumerable check, and finally properties.\par
}
</Notes>
  </Step>
  <Step Number="34">
    <GhostKeyboardData>[GotoLine 102][End][Pause 1]

private int GetAggregatedHashCode(Type type, IEnumerable&lt;object&gt; values)
{
unchecked
{
return
values.Aggregate(
    type.FullName.GetHashCode(),
(hashCode, value) =&gt; (hashCode * 397) ^ this.GetHashCode(value));</GhostKeyboardData>
    <FinishedCode>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Consolas;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red163\green21\blue21;}
\viewkind4\uc1\pard\cf1\highlight2\f0\fs22 using\cf3  System;\par
\cf1 using\cf3  System.Linq;\par
\cf1 using\cf3  System.Collections;\par
\cf1 using\cf3  System.Collections.Generic;\par
\cf1 using\cf3  System.Collections.Concurrent;\par
\cf1 using\cf3  System.Reflection;\par
\cf1 using\cf3  System.Linq.Expressions;\par
\par
\cf1 namespace\cf3  MetaDemo\par
\{\par
    \cf1 public\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 DeepEqualityComparer\cf3  : \cf4 IEqualityComparer\cf3\par
    \{\par
        \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 DeepEqualityComparer\cf3  _instance = \cf1 new\cf3  \cf4 DeepEqualityComparer\cf3 ();\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 Type\cf3 [] _primitivishTypes =\par
        \{\par
            \cf1 typeof\cf3 (\cf1 string\cf3 ),\par
            \cf1 typeof\cf3 (\cf1 decimal\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 DateTime\cf3 ),\par
            \cf1 typeof\cf3 (\cf4 Guid\cf3 )\par
        \};\par
\par
        \cf1 private\cf3  \cf1 readonly\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt; _propertyAccessorsMap =\par
            \cf1 new\cf3  \cf4 ConcurrentDictionary\cf3 &lt;\cf4 Type\cf3 , \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;&gt;();\par
\par
        \cf1 private\cf3  DeepEqualityComparer()\par
        \{\par
        \}\par
\par
        \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3  Instance\par
        \{\par
            \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
        \}\par
\par
        \cf1 private\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; GetGenericInstance&lt;T&gt;()\par
        \{\par
            \cf1 return\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;.Instance;\par
        \}\par
\par
        \cf1 public\cf3  \cf1 bool\cf3  Equals(\cf1 object\cf3  lhs, \cf1 object\cf3  rhs)\par
        \{\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3  &amp;&amp; rhs == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  \cf1 true\cf3 ;\par
            \}\par
\par
            \cf1 if\cf3  (lhs == \cf1 null\cf3\par
                || rhs == \cf1 null\cf3\par
                || lhs.GetType() != rhs.GetType())\par
            \{\par
                \cf1 return\cf3  \cf1 false\cf3 ;\par
            \}\par
\par
            \cf1 var\cf3  type = lhs.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  lhs.Equals(rhs);\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 var\cf3  lhsList = ((\cf4 IEnumerable\cf3 )lhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
                \cf1 var\cf3  rhsList = ((\cf4 IEnumerable\cf3 )rhs).Cast&lt;\cf1 object\cf3 &gt;().ToList();\par
\par
                \cf1 if\cf3  (lhsList.Count != rhsList.Count)\par
                \{\par
                    \cf1 return\cf3  \cf1 false\cf3 ;\par
                \}\par
\par
                \cf1 return\cf3\par
                    lhsList\par
                        .Zip(rhsList, (l, r) =&gt; \cf1 this\cf3 .Equals(l, r))\par
                        .All(x =&gt; x);\par
            \}\par
\par
            \cf1 return\cf3\par
                GetPropertyAccessors(type)\par
                    .All(getPropertyValue =&gt; \cf1 this\cf3 .Equals(getPropertyValue(lhs), getPropertyValue(rhs)));\par
        \}\par
\par
        \cf1 public\cf3  \cf1 int\cf3  GetHashCode(\cf1 object\cf3  obj)\par
        \{\par
            \cf1 if\cf3  (obj == \cf1 null\cf3 )\par
            \{\par
                \cf1 return\cf3  0;\par
            \}\par
\par
            \cf1 var\cf3  type = obj.GetType();\par
\par
            \cf1 if\cf3  (IsPrimitivish(type))\par
            \{\par
                \cf1 return\cf3  \f1 obj\f0 .GetHashCode();\par
            \}\par
\par
            \cf1 if\cf3  (\cf1 typeof\cf3 (\cf4 IEnumerable\cf3 ).IsAssignableFrom(type))\par
            \{\par
                \cf1 return\cf3  \cf1 this\cf3 .GetAggregatedHashCode(type, ((\cf4 IEnumerable\cf3 )obj).Cast&lt;\cf1 object\cf3 &gt;());\par
            \}\par
\par
            \cf1 return\cf3  \cf1 this\cf3 .GetAggregatedHashCode(type, GetPropertyAccessors(type).Select(getPropertyValue =&gt; getPropertyValue(obj)));\par
        \}\par
\par
        \cf1 private\cf3  \cf1 int\cf3  GetAggregatedHashCode(\cf4 Type\cf3  type, \cf4 IEnumerable\cf3 &lt;\cf1 object\cf3 &gt; values)\par
        \{\par
            \cf1 unchecked\cf3\par
            \{\par
                \cf1 return\cf3\par
                    values.Aggregate(\par
                        type.FullName.GetHashCode(),\par
                        (hashCode, value) =&gt; (hashCode * 397) ^ \cf1 this\cf3 .GetHashCode(value));\par
            \}\par
        \}\par
\par
        \cf1 private\cf3  \cf4 IEnumerable\cf3 &lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt; GetPropertyAccessors(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                _propertyAccessorsMap.GetOrAdd(\par
                     type,\par
                     t =&gt;\par
                     (\cf1 from\cf3  p \cf1 in\cf3  t.GetProperties()\par
                      \cf1 where\cf3  p.CanRead\par
                      \cf1 let\cf3  getMethod = p.GetGetMethod()\par
                      \cf1 where\cf3  getMethod != \cf1 null\cf3  &amp;&amp; getMethod.IsPublic\par
                      \cf1 select\cf3  CreatePropertyAccessor(p)).ToList());\par
        \}\par
\par
        \cf1 private\cf3  \cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt; CreatePropertyAccessor(\cf4 PropertyInfo\cf3  property)\par
        \{\par
            \cf1 var\cf3  objParameter = \cf4 Expression\cf3 .Parameter(\cf1 typeof\cf3 (\cf1 object\cf3 ), \cf5 "obj"\cf3 );\par
\par
            \cf4 Expression\cf3  getPropertyValueExpression =\par
                \cf4 Expression\cf3 .Property(\par
                    \cf4 Expression\cf3 .Convert(\par
                        objParameter,\par
                        property.DeclaringType),\par
                    property);\par
\par
            \cf1 if\cf3  (property.PropertyType.IsValueType)\par
            \{\par
                getPropertyValueExpression = \cf4 Expression\cf3 .Convert(getPropertyValueExpression, \cf1 typeof\cf3 (\cf1 object\cf3 ));\par
            \}\par
\par
            \cf1 var\cf3  lambda = \cf4 Expression\cf3 .Lambda&lt;\cf4 Func\cf3 &lt;\cf1 object\cf3 , \cf1 object\cf3 &gt;&gt;(getPropertyValueExpression, objParameter);\par
            \cf1 return\cf3  lambda.Compile();\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsPrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  IsNonNullablePrimitivish(type) || IsNullablePrimitivish(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNonNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3  type.IsPrimitive || _primitivishTypes.Contains(type);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 bool\cf3  IsNullablePrimitivish(\cf4 Type\cf3  type)\par
        \{\par
            \cf1 return\cf3\par
                type.IsGenericType\par
                &amp;&amp; type.GetGenericTypeDefinition() == \cf1 typeof\cf3 (\cf4 Nullable\cf3 &lt;&gt;)\par
                &amp;&amp; IsNonNullablePrimitivish(type.GetGenericArguments()[0]);\par
        \}\par
\par
        \cf1 private\cf3  \cf1 sealed\cf3  \cf1 class\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; : \cf4 IEqualityComparer\cf3 &lt;T&gt;\par
        \{\par
            \cf1 private\cf3  \cf1 static\cf3  \cf1 readonly\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt; _instance = \cf1 new\cf3  \cf4 GenericDeepEqualityComparer\cf3 &lt;T&gt;();\par
\par
            \cf1 private\cf3  GenericDeepEqualityComparer()\par
            \{\par
            \}\par
\par
            \cf1 public\cf3  \cf1 static\cf3  \cf4 IEqualityComparer\cf3 &lt;T&gt; Instance\par
            \{\par
                \cf1 get\cf3  \{ \cf1 return\cf3  _instance; \}\par
            \}\par
\par
            \cf1 public\cf3  \cf1 bool\cf3  Equals(T lhs, T rhs)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.Equals(lhs, rhs);\par
            \}\par
\par
            \cf1 public\cf3  \cf1 int\cf3  GetHashCode(T obj)\par
            \{\par
                \cf1 return\cf3  \cf4 DeepEqualityComparer\cf3 .Instance.GetHashCode(obj);\par
            \}\par
        \}\par
    \}\par
\}\cf0\highlight0\f1\fs24\par
}
</FinishedCode>
    <Notes>{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fnil\fcharset0 Microsoft Sans Serif;}}
\viewkind4\uc1\pard\f0\fs24 And there you have it. A fully-functional, deep property-comparing implementation of IEqualityComparer.\par
}
</Notes>
  </Step>
</Demo>